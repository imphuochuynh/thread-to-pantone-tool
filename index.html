<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minh Shyang 100% Polyester Thread to Pantone Color Matcher</title>
    <!-- Add PapaParse library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --background-color: #f5f6fa;
            --card-background: #ffffff;
            --text-color: #333333;
            --secondary-text: #666666;
            --light-text: #888888;
            --border-color: #dddddd;
            --hover-color: #f0f0f0;
            --alternative-bg: #f9f9f9;
        }

        [data-theme="dark"] {
            --primary-color: #61dafb;
            --background-color: #1a1a1a;
            --card-background: #2d2d2d;
            --text-color: #f0f0f0;
            --secondary-text: #cccccc;
            --light-text: #aaaaaa;
            --border-color: #444444;
            --hover-color: #3d3d3d;
            --alternative-bg: #333333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .search-section {
            background-color: var(--card-background);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .search-section-title {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }

        .search-section-title svg {
            margin-right: 8px;
        }

        .search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--card-background);
            color: var(--text-color);
            transition: border-color 0.3s;
        }

        .search-box:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.1);
        }

        .hex-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .hex-input-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: var(--secondary-text);
        }

        .hex-input {
            width: 120px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--card-background);
            color: var(--text-color);
            transition: border-color 0.3s;
        }

        .hex-input:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.1);
        }

        .hex-preview {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }

        .hex-preview:hover {
            transform: scale(1.1);
        }

        .hex-submit {
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hex-submit:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .hex-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .color-card {
            background: var(--card-background);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .color-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
        }

        .color-swatch {
            height: 100px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.02);
        }

        .color-info {
            text-align: left;
        }

        .color-name {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .color-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .color-match {
            color: var(--secondary-text);
            font-size: 0.95em;
            margin-top: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .match-details {
            flex: 1;
        }

        .match-name {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .match-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .similarity {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .similarity.high-match {
            background-color: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
        }

        .similarity.medium-match {
            background-color: rgba(255, 193, 7, 0.1);
            color: #FFC107;
        }

        .similarity.low-match {
            background-color: rgba(244, 67, 54, 0.1);
            color: #F44336;
        }

        .similarity-value {
            font-weight: 600;
        }

        .match-method {
            font-size: 0.85em;
            color: var(--secondary-text);
            margin-top: 5px;
            padding: 2px 6px;
            background-color: var(--alternative-bg);
            border-radius: 4px;
            display: inline-block;
        }

        .high-match {
            color: #2ecc71;
        }

        .hex-value {
            font-family: monospace;
            font-size: 0.9em;
            color: var(--light-text);
        }

        .no-results {
            text-align: center;
            padding: 40px;
            background: var(--card-background);
            border-radius: 8px;
            color: var(--secondary-text);
            font-size: 1.1em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--secondary-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #pagination {
            display: none;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        #pagination button {
            padding: 12px 20px;
            background-color: var(--card-background);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #pagination button:hover {
            background-color: var(--hover-color);
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .footer {
            margin-top: 40px;
            margin-bottom: 20px;
            text-align: center;
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .footer a {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .footer a:hover {
            text-decoration: underline;
            transform: translateY(-2px);
        }

        .color-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
            background-color: var(--alternative-bg);
        }

        .rgb-value {
            font-size: 0.8em;
            color: var(--light-text);
            margin-top: 4px;
        }

        .alternatives-section {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px dashed var(--border-color);
        }

        .alternatives-title {
            font-size: 0.9em;
            color: var(--secondary-text);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .color-match.alternative {
            margin-top: 6px;
            padding: 4px 6px;
            background-color: var(--alternative-bg);
            border-radius: 4px;
            font-size: 0.9em;
        }

        .about-link {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9em;
            color: var(--secondary-text);
        }

        .about-link a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .about-link a:hover {
            text-decoration: underline;
        }

        .disclaimer {
            margin-top: 8px;
            font-size: 0.8em;
            color: var(--light-text);
            font-style: italic;
        }

        .status-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--card-background);
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: var(--secondary-text);
            z-index: 100;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
            border: 1px solid var(--border-color);
        }

        .status-indicator.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .status-indicator .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4CAF50;
        }

        .status-indicator .status-dot.loading {
            background-color: #FFC107;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        @media (max-width: 600px) {
            .search-box {
                max-width: 100%;
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
                text-align: center;
                flex: 100%;
            }
            
            .header {
                justify-content: center;
            }
            
            .theme-switch-wrapper {
                margin-top: 10px;
            }
        }

        .color-match-method {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--alternative-bg);
            border-radius: 6px;
            width: 100%;
        }
        
        .color-match-method > span {
            font-size: 0.9em;
            color: var(--secondary-text);
            margin-bottom: 8px;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .radio-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .radio-label:hover {
            background-color: var(--hover-color);
        }
        
        .radio-label input[type="radio"] {
            margin: 0;
        }
        
        .radio-label span {
            font-size: 0.9em;
        }
        
        .method-banner {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--alternative-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .method-icon {
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .method-text {
            font-size: 1em;
            color: var(--text-color);
        }
        
        .method-text strong {
            color: var(--primary-color);
        }
        
        .banner-container {
            margin-bottom: 20px;
            width: 100%;
        }
        
        #results-container {
            width: 100%;
        }
        
        .disclaimer-section {
            margin: 30px 0;
            width: 100%;
        }
        
        .disclaimer-box {
            background-color: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        
        .disclaimer-icon {
            color: #FFC107;
            flex-shrink: 0;
            margin-top: 2px;
        }
        
        .disclaimer-text {
            font-size: 0.95em;
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .disclaimer-text strong {
            color: #FFC107;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Minh Shyang 100% Polyester Thread to Pantone Color Matcher</h1>
            <div class="theme-switch-wrapper">
                <span class="theme-icon">☀️</span>
                <label class="theme-switch">
                    <input type="checkbox" id="themeToggle">
                    <span class="slider"></span>
                </label>
                <span class="theme-icon">🌙</span>
            </div>
        </div>
        
        <div class="search-section">
            <h2 class="search-section-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                Search Colors
            </h2>
            <div class="search-container">
                <input type="text" id="colorSearch" class="search-box" placeholder="Search by thread code or Pantone color">
                <div class="color-match-method">
                    <span>Matching Method:</span>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="searchColorMatchMethod" value="rgb" checked>
                            <span>RGB (Basic)</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="searchColorMatchMethod" value="lab">
                            <span>CIELAB (Perceptual)</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <h2 class="search-section-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                    <polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline>
                    <polyline points="7.5 19.79 7.5 14.6 3 12"></polyline>
                    <polyline points="21 12 16.5 14.6 16.5 19.79"></polyline>
                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                </svg>
                Find by Hex Color
            </h2>
            <div class="hex-input-container">
                <div class="hex-input-label">
                    <span>Preview:</span>
                    <div class="hex-preview"></div>
                </div>
                <input type="text" id="hexInput" class="hex-input" placeholder="#HEXCODE">
                <button id="hexSubmit" class="hex-submit" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    Find Matches
                </button>
                <div class="color-match-method">
                    <span>Matching Method:</span>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="colorMatchMethod" value="rgb" checked>
                            <span>RGB (Basic)</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="colorMatchMethod" value="lab">
                            <span>CIELAB (Perceptual)</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="results-container">
            <div id="results" class="results"></div>
        </div>
        
        <div id="pagination">
            <button id="prevPage">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Previous
            </button>
            <button id="nextPage">
                Next
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                    <polyline points="12 5 19 12 12 19"></polyline>
                </svg>
            </button>
        </div>
        
        <div class="disclaimer-section">
            <div class="disclaimer-box">
                <div class="disclaimer-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                </div>
                <div class="disclaimer-text">
                    <strong>Disclaimer:</strong> This tool was created as an AI experiment and is intended for general reference and exploratory use. The Pantone matches provided in this tool may not be fully accurate. Users are encouraged to exercise discretion and independently verify all matches for precision.
                </div>
            </div>
        </div>
        
        <div class="footer">
            <a href="about.html">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                </svg>
                About
            </a>
            <a href="#" id="resetColors">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                    <path d="M3 3v5h5"></path>
                </svg>
                Reset
            </a>
        </div>
    </div>

    <div class="status-indicator">
        <span class="status-dot"></span>
        <span class="status-text">Loading...</span>
    </div>

    <script>
        let threadData = [];
        let pantoneData = [];
        let pantoneToThreadData = [];
        let allColors = [];
        let currentPage = 1;
        const itemsPerPage = 10;
        let filteredColors = [];

        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('themeToggle');
            
            // Check for saved theme preference or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Set initial theme
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.checked = true;
            }
            
            // Handle theme toggle
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    localStorage.setItem('theme', 'light');
                }
            });
            
            // Load color data
            loadColorData();
        });
        
        async function loadColorData() {
            showStatus('Loading thread data...', true);
            try {
                // Load thread data using PapaParse
                const threadResponse = await fetch('Reformatted_Embroidery_Thread_Data.csv');
                const threadCsvText = await threadResponse.text();
                
                Papa.parse(threadCsvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        threadData = results.data.map(row => ({
                            type: 'thread',
                            code: row['Thread Code'],
                            rgb: {
                                r: parseInt(row['R']),
                                g: parseInt(row['G']),
                                b: parseInt(row['B'])
                            }
                        }));
                        console.log(`Loaded ${threadData.length} thread colors`);
                        showStatus(`Loaded ${threadData.length} thread colors`, false);
                        
                        // Continue with loading other data
                        loadPantoneData();
                    },
                    error: function(error) {
                        console.error('Error parsing thread data:', error);
                        document.getElementById('results').innerHTML = 
                            `<div class="no-results">Error loading thread data: ${error.message}</div>`;
                        showStatus('Error loading thread data', false);
                    }
                });
            } catch (error) {
                console.error('Error loading color data:', error);
                document.getElementById('results').innerHTML = 
                    `<div class="no-results">Error loading color data: ${error.message}</div>`;
                showStatus('Error loading color data', false);
            }
        }
        
        async function loadPantoneData() {
            try {
                // Load Pantone colors
                const pantoneResponse = await fetch('all_pantone_colors_with_rgb.json');
                const pantoneJson = await pantoneResponse.json();
                
                pantoneData = pantoneJson.pantone_colors.map(color => {
                    return {
                        type: 'pantone',
                        code: color.name.trim(),
                        rgb: {
                            r: color.rgb.r,
                            g: color.rgb.g,
                            b: color.rgb.b
                        }
                    };
                });
                console.log(`Loaded ${pantoneData.length} Pantone colors`);
                
                // Continue with loading match data
                loadMatchData();
            } catch (error) {
                console.error('Error loading Pantone data:', error);
                document.getElementById('results').innerHTML = 
                    `<div class="no-results">Error loading Pantone data: ${error.message}</div>`;
            }
        }
        
        async function loadMatchData() {
            try {
                // Load Pantone to thread matches using PapaParse
                const matchesResponse = await fetch('matched_Pantone_to_embroidery_threads.csv');
                const matchesCsvText = await matchesResponse.text();
                
                Papa.parse(matchesCsvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        pantoneToThreadData = results.data.map(row => {
                            // Parse RGB values from strings like "(r, g, b)"
                            const pantoneRgbStr = row['Pantone RGB'].replace(/[()"\s]/g, '').split(',');
                            const threadRgbStr = row['Matched RGB'].replace(/[()"\s]/g, '').split(',');
                            
                            return {
                                pantoneCode: row['Pantone Color'].trim(),
                                pantoneRgb: {
                                    r: parseInt(pantoneRgbStr[0]),
                                    g: parseInt(pantoneRgbStr[1]),
                                    b: parseInt(pantoneRgbStr[2])
                                },
                                threadCode: row['Matched Thread Code'].trim(),
                                threadRgb: {
                                    r: parseInt(threadRgbStr[0]),
                                    g: parseInt(threadRgbStr[1]),
                                    b: parseInt(threadRgbStr[2])
                                },
                                distance: parseFloat(row['Distance'])
                            };
                        }).filter(item => item !== null);
                        
                        console.log(`Loaded ${pantoneToThreadData.length} Pantone to thread matches`);
                        
                        // Process and display the data
                        processAndDisplayData();
                    },
                    error: function(error) {
                        console.error('Error parsing match data:', error);
                        document.getElementById('results').innerHTML = 
                            `<div class="no-results">Error loading match data: ${error.message}</div>`;
                    }
                });
            } catch (error) {
                console.error('Error loading match data:', error);
                document.getElementById('results').innerHTML = 
                    `<div class="no-results">Error loading match data: ${error.message}</div>`;
            }
        }
        
        function processAndDisplayData() {
            // Combine thread and pantone data
            allColors = [...threadData, ...pantoneData];
            console.log(`Combined ${allColors.length} total colors`);
            
            // Get the selected color matching method
            const colorMatchMethod = document.querySelector('input[name="searchColorMatchMethod"]:checked').value;
            
            // Enhance thread data with pantone matches and alternatives
            threadData.forEach(thread => {
                // Find all pantone matches for this thread
                const matches = pantoneToThreadData
                    .filter(m => m.threadCode === thread.code)
                    .sort((a, b) => a.distance - b.distance);
                
                if (matches.length > 0) {
                    // Primary match
                    const primaryMatch = matches[0];
                    thread.matchCode = primaryMatch.pantoneCode;
                    thread.matchRgb = primaryMatch.pantoneRgb;
                    thread.distance = primaryMatch.distance;
                    thread.matchMethod = colorMatchMethod; // Store the method used
                    
                    // Alternative matches (if any)
                    if (matches.length > 1) {
                        thread.alternativeMatches = matches.slice(1, 3).map(m => ({
                            code: m.pantoneCode,
                            rgb: m.pantoneRgb,
                            distance: m.distance,
                            type: 'pantone'
                        }));
                    }
                } else {
                    // If no exact match, find closest pantone colors by selected method
                    thread.alternativeMatches = findClosestColorsWithMethod(thread, pantoneData, 2, colorMatchMethod, []);
                    thread.matchMethod = colorMatchMethod; // Store the method used
                }
            });
            
            // Enhance pantone data with thread matches and alternatives
            pantoneData.forEach(pantone => {
                // Find the thread match for this pantone
                const match = pantoneToThreadData.find(m => m.pantoneCode === pantone.code);
                
                if (match) {
                    pantone.matchCode = match.threadCode;
                    pantone.matchRgb = match.threadRgb;
                    pantone.distance = match.distance;
                    pantone.matchMethod = colorMatchMethod; // Store the method used
                    
                    // Find alternative thread matches
                    pantone.alternativeMatches = findClosestColorsWithMethod(pantone, threadData, 2, colorMatchMethod, [match.threadCode]);
                } else {
                    // If no exact match, find closest thread colors by selected method
                    pantone.alternativeMatches = findClosestColorsWithMethod(pantone, threadData, 2, colorMatchMethod, []);
                    pantone.matchMethod = colorMatchMethod; // Store the method used
                }
            });
            
            // Display all colors initially
            filteredColors = allColors;
            displayColors(filteredColors, currentPage);
        }

        // Calculate RGB distance between two colors
        function rgbDistance(color1, color2) {
            const dr = color1.rgb.r - color2.rgb.r;
            const dg = color1.rgb.g - color2.rgb.g;
            const db = color1.rgb.b - color2.rgb.b;
            return Math.sqrt(dr*dr + dg*dg + db*db);
        }
        
        // Find closest colors by RGB distance
        function findClosestColors(sourceColor, targetColors, count = 2, excludeCodes = []) {
            return targetColors
                .filter(color => !excludeCodes.includes(color.code))
                .map(color => ({
                    code: color.code,
                    rgb: color.rgb,
                    distance: rgbDistance(sourceColor, color)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, count);
        }
        
        // Find closest colors using the specified method (RGB or CIELAB)
        function findClosestColorsWithMethod(sourceColor, targetColors, count = 2, method = 'rgb', excludeCodes = []) {
            return targetColors
                .filter(color => !excludeCodes.includes(color.code))
                .map(color => ({
                    code: color.code,
                    rgb: color.rgb,
                    type: color.type,
                    distance: calculateColorDistance(sourceColor.rgb, color.rgb, method)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, count);
        }

        function displayColors(colors, page = 1) {
            const resultsDiv = document.getElementById('results');
            const resultsContainer = document.getElementById('results-container');
            resultsDiv.innerHTML = '';
            
            // Remove any existing banner
            const existingBanner = document.querySelector('.banner-container');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            if (colors.length === 0) {
                resultsDiv.innerHTML = '<div class="no-results">No colors found</div>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Calculate pagination
            const startIndex = (page - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, colors.length);
            const pageColors = colors.slice(startIndex, endIndex);
            
            // Update pagination controls
            document.getElementById('pagination').style.display = 'flex';
            document.getElementById('prevPage').disabled = page === 1;
            document.getElementById('nextPage').disabled = endIndex >= colors.length;
            
            // Show status with count
            showStatus(`Showing ${startIndex + 1}-${endIndex} of ${colors.length} colors`, false);
            
            // If we're displaying a custom color, show the matching method at the top
            if (pageColors.length === 1 && pageColors[0].type === 'custom' && pageColors[0].matchMethod) {
                const methodBanner = document.createElement('div');
                methodBanner.className = 'method-banner';
                methodBanner.innerHTML = `
                    <div class="method-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                    </div>
                    <div class="method-text">
                        Using <strong>${pageColors[0].matchMethod === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'}</strong> color matching method
                    </div>
                `;
                
                // Create a container for the banner that's outside the grid
                const bannerContainer = document.createElement('div');
                bannerContainer.className = 'banner-container';
                bannerContainer.appendChild(methodBanner);
                resultsContainer.insertBefore(bannerContainer, resultsDiv);
            }
            // Show the matching method banner for regular searches too
            else if (pageColors.length > 0 && pageColors[0].matchMethod) {
                const methodBanner = document.createElement('div');
                methodBanner.className = 'method-banner';
                methodBanner.innerHTML = `
                    <div class="method-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                    </div>
                    <div class="method-text">
                        Using <strong>${pageColors[0].matchMethod === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'}</strong> color matching method for all results
                    </div>
                `;
                
                // Create a container for the banner that's outside the grid
                const bannerContainer = document.createElement('div');
                bannerContainer.className = 'banner-container';
                bannerContainer.appendChild(methodBanner);
                resultsContainer.insertBefore(bannerContainer, resultsDiv);
            }

            pageColors.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-card';
                
                const colorRGB = `rgb(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b})`;
                const hexColor = rgbToHex(color.rgb.r, color.rgb.g, color.rgb.b);
                
                // Primary match HTML
                let matchHTML = '';
                if (color.matchCode) {
                    // Use matchType property if available, otherwise determine based on color type
                    const matchType = color.matchType ? 
                        (color.matchType === 'pantone' ? 'Pantone' : 'Thread') : 
                        (color.type === 'pantone' ? 'Thread' : 'Pantone');
                    const matchRGB = `rgb(${color.matchRgb.r}, ${color.matchRgb.g}, ${color.matchRgb.b})`;
                    const matchHex = rgbToHex(color.matchRgb.r, color.matchRgb.g, color.matchRgb.b);
                    const similarity = (100 - Math.min(color.distance, 100)).toFixed(1);
                    const similarityClass = similarity >= 90 ? 'high-match' : similarity >= 75 ? 'medium-match' : 'low-match';
                    
                    // Display the matching method if it's a custom color
                    const matchMethodHTML = color.matchMethod ? 
                        `<div class="match-method">Method: ${color.matchMethod === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'}</div>` : '';
                    
                    matchHTML = `
                        <div class="color-match">
                            <span class="match-swatch" style="background-color: ${matchRGB}"></span>
                            <div class="match-details">
                                <div class="match-name">${matchType}: ${color.matchCode}</div>
                                <div class="rgb-value">RGB: ${color.matchRgb.r}, ${color.matchRgb.g}, ${color.matchRgb.b}</div>
                                <div class="hex-value">Hex: ${matchHex}</div>
                                <div class="similarity ${similarityClass}">
                                    <span class="similarity-label">Similarity:</span>
                                    <span class="similarity-value">${similarity}%</span>
                                </div>
                                ${matchMethodHTML}
                            </div>
                        </div>
                    `;
                }
                
                // Alternative matches HTML
                let alternativesHTML = '';
                if (color.alternativeMatches && color.alternativeMatches.length > 0) {
                    // Use matchType property if available, otherwise determine based on color type
                    const matchType = color.matchType ? 
                        (color.matchType === 'pantone' ? 'Thread' : 'Pantone') : 
                        (color.type === 'pantone' ? 'Thread' : 'Pantone');
                    alternativesHTML = `
                        <div class="alternatives-section">
                            <div class="alternatives-title">Alternative ${matchType} Matches:</div>
                            ${color.alternativeMatches.map(alt => {
                                const altRGB = `rgb(${alt.rgb.r}, ${alt.rgb.g}, ${alt.rgb.b})`;
                                const altHex = rgbToHex(alt.rgb.r, alt.rgb.g, alt.rgb.b);
                                const similarity = (100 - Math.min(alt.distance, 100)).toFixed(1);
                                const similarityClass = similarity >= 90 ? 'high-match' : similarity >= 75 ? 'medium-match' : 'low-match';
                                
                                // Add the type label (Pantone or Thread) to each alternative match
                                const altType = alt.type === 'pantone' ? 'Pantone' : 'Thread';
                                
                                return `
                                    <div class="color-match alternative">
                                        <span class="match-swatch" style="background-color: ${altRGB}"></span>
                                        <div class="match-details">
                                            <div class="match-name">${altType}: ${alt.code}</div>
                                            <div class="hex-value">Hex: ${altHex}</div>
                                            <div class="similarity ${similarityClass}">
                                                <span class="similarity-value">${similarity}%</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                }
                
                colorDiv.innerHTML = `
                    <div class="color-swatch" style="background-color: ${colorRGB}"></div>
                    <div class="color-info">
                        <div class="color-name">
                            ${color.code}
                            <span class="color-type">${color.type === 'thread' ? 'Thread' : color.type === 'custom' ? 'Custom' : 'Pantone'}</span>
                        </div>
                        <div class="color-details">
                            <div class="rgb-value">RGB: ${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b}</div>
                            <div class="hex-value">Hex: ${hexColor}</div>
                        </div>
                        ${matchHTML}
                        ${alternativesHTML}
                    </div>
                `;
                
                resultsDiv.appendChild(colorDiv);
            });
        }

        document.getElementById('colorSearch').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            
            if (searchTerm.trim() === '') {
                filteredColors = allColors;
            } else {
                filteredColors = allColors.filter(color => 
                    color.code.toLowerCase().includes(searchTerm) || 
                    (color.matchCode && color.matchCode.toLowerCase().includes(searchTerm))
                );
            }
            
            currentPage = 1;
            displayColors(filteredColors, currentPage);
        });

        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                displayColors(filteredColors, currentPage);
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            if (currentPage * itemsPerPage < filteredColors.length) {
                currentPage++;
                displayColors(filteredColors, currentPage);
            }
        });

        document.getElementById('hexInput').addEventListener('input', (e) => {
            const hexInput = e.target;
            const hexSubmit = document.getElementById('hexSubmit');
            const hexPreview = document.querySelector('.hex-preview');
            let hexCode = hexInput.value.trim();
            
            if (isValidHexColor(hexCode)) {
                hexCode = normalizeHexColor(hexCode);
                hexInput.value = hexCode;
                hexPreview.style.backgroundColor = hexCode;
                hexSubmit.disabled = false;
            } else {
                hexPreview.style.backgroundColor = 'transparent';
                hexSubmit.disabled = true;
            }
        });
        
        document.getElementById('hexSubmit').addEventListener('click', () => {
            const hexInput = document.getElementById('hexInput');
            const hexCode = hexInput.value.trim();
            
            if (isValidHexColor(hexCode)) {
                const normalizedHex = normalizeHexColor(hexCode);
                const rgb = hexToRgb(normalizedHex);
                
                // Get the selected color matching method
                const colorMatchMethod = document.querySelector('input[name="colorMatchMethod"]:checked').value;
                
                // Find closest Pantone colors using the selected method
                const closestPantoneColors = findClosestColorsToHex(normalizedHex, pantoneData, 3, colorMatchMethod);
                
                // Find closest thread colors using the selected method
                const closestThreadColors = findClosestColorsToHex(normalizedHex, threadData, 3, colorMatchMethod);
                
                // Create a custom color object with matches
                const customColor = {
                    type: 'custom',
                    code: normalizedHex,
                    rgb: rgb,
                    matchCode: closestPantoneColors[0].code,
                    matchRgb: closestPantoneColors[0].rgb,
                    distance: closestPantoneColors[0].distance,
                    matchMethod: colorMatchMethod, // Store the method used for matching
                    matchType: 'pantone', // Explicitly indicate the primary match is a Pantone color
                    alternativeMatches: [
                        ...closestPantoneColors.slice(1).map(c => ({...c, type: 'pantone'})),
                        ...closestThreadColors.map(c => ({...c, type: 'thread'}))
                    ]
                };
                
                // Display the custom color and its matches
                filteredColors = [customColor];
                currentPage = 1;
                displayColors(filteredColors, currentPage);
                
                // Show a status message about the matching method used
                showStatus(`Using ${colorMatchMethod === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'} color matching`, false, 6000);
            }
        });

        function isValidHexColor(hex) {
            return /^#?[0-9A-Fa-f]{6}$/.test(hex);
        }
        
        function normalizeHexColor(hex) {
            hex = hex.trim();
            if (!hex.startsWith('#')) {
                hex = '#' + hex;
            }
            return hex.toUpperCase();
        }
        
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            return {
                r: parseInt(hex.slice(0, 2), 16),
                g: parseInt(hex.slice(2, 4), 16),
                b: parseInt(hex.slice(4, 6), 16)
            };
        }
        
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = Math.max(0, Math.min(255, x)).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }
        
        // RGB to CIELAB conversion functions
        function rgbToXyz(rgb) {
            // Convert RGB to normalized values
            let r = rgb.r / 255;
            let g = rgb.g / 255;
            let b = rgb.b / 255;
            
            // Apply gamma correction
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            
            // Convert to XYZ color space
            const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
            
            return { x: x * 100, y: y * 100, z: z * 100 };
        }
        
        function xyzToLab(xyz) {
            // Reference values for D65 standard illuminant
            const xRef = 95.047;
            const yRef = 100.0;
            const zRef = 108.883;
            
            // Normalize XYZ values
            let x = xyz.x / xRef;
            let y = xyz.y / yRef;
            let z = xyz.z / zRef;
            
            // Apply transformation
            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
            
            const L = (116 * y) - 16;
            const a = 500 * (x - y);
            const b = 200 * (y - z);
            
            return { L, a, b };
        }
        
        function rgbToLab(rgb) {
            const xyz = rgbToXyz(rgb);
            return xyzToLab(xyz);
        }
        
        function calculateLabDistance(lab1, lab2) {
            // Calculate Euclidean distance in CIELAB color space
            return Math.sqrt(
                Math.pow(lab1.L - lab2.L, 2) +
                Math.pow(lab1.a - lab2.a, 2) +
                Math.pow(lab1.b - lab2.b, 2)
            );
        }
        
        function calculateColorDistance(rgb1, rgb2, method = 'rgb') {
            if (method === 'lab') {
                const lab1 = rgbToLab(rgb1);
                const lab2 = rgbToLab(rgb2);
                return calculateLabDistance(lab1, lab2);
            } else {
                // Default RGB Euclidean distance
                return Math.sqrt(
                    Math.pow(rgb1.r - rgb2.r, 2) +
                    Math.pow(rgb1.g - rgb2.g, 2) +
                    Math.pow(rgb1.b - rgb2.b, 2)
                );
            }
        }
        
        function findClosestColorsToHex(hexCode, colorData, limit = 3, method = 'rgb') {
            const targetRgb = hexToRgb(hexCode);
            
            return colorData
                .map(color => ({
                    ...color,
                    distance: calculateColorDistance(targetRgb, color.rgb, method)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, limit);
        }

        // Function to show status indicator
        function showStatus(message, isLoading = false, duration = 3000) {
            const statusIndicator = document.querySelector('.status-indicator');
            const statusDot = statusIndicator.querySelector('.status-dot');
            const statusText = statusIndicator.querySelector('.status-text');
            
            statusText.textContent = message;
            
            if (isLoading) {
                statusDot.classList.add('loading');
            } else {
                statusDot.classList.remove('loading');
            }
            
            statusIndicator.classList.add('visible');
            
            // Hide status after specified duration if not loading
            if (!isLoading) {
                setTimeout(() => {
                    statusIndicator.classList.remove('visible');
                }, duration);
            }
        }

        document.getElementById('resetColors').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('colorSearch').value = '';
            document.getElementById('hexInput').value = '';
            document.querySelector('.hex-preview').style.backgroundColor = 'transparent';
            document.getElementById('hexSubmit').disabled = true;
            
            filteredColors = allColors;
            currentPage = 1;
            displayColors(filteredColors, currentPage);
            
            showStatus('Colors reset to default view', false);
        });

        // Initial display
        window.addEventListener('load', () => {
            // Show loading state
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>Loading color data...</div>
                </div>
            `;
            
            // Load color data
            loadColorData();
            
            // Set up the color matching method radio buttons
            const colorMatchMethodRadios = document.querySelectorAll('input[name="colorMatchMethod"]');
            colorMatchMethodRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (filteredColors.length === 1 && filteredColors[0].type === 'custom') {
                        // Show a status message about the matching method change
                        showStatus(`Switching to ${this.value === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'} color matching`, false, 3000);
                        
                        // Trigger the hex submit button click to refresh the results
                        document.getElementById('hexSubmit').click();
                    }
                });
            });
        });

        // Add event listener for search color match method change
        document.querySelectorAll('input[name="searchColorMatchMethod"]').forEach(radio => {
            radio.addEventListener('change', function() {
                // Show a status message about the matching method change
                showStatus(`Switching to ${this.value === 'rgb' ? 'RGB (Basic)' : 'CIELAB (Perceptual)'} color matching`, false, 3000);
                
                // Reprocess and redisplay the data with the new method
                processAndDisplayData();
            });
        });
    </script>
</body>
</html> 